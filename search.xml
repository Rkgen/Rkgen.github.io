<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[UGUI实现窗口切换动画]]></title>
    <url>%2F2019%2F06%2F20%2FUGUI%E5%AE%9E%E7%8E%B0%E7%AA%97%E5%8F%A3%E5%88%87%E6%8D%A2%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[前言在开发的过程中我们常常需要创建很多UI窗口，如何让这些窗口按照递归的方式而且还是带动画地进行切换呢，本文介绍了一种方法实现这个功能 思路为了实现这样的效果，需要搭建一个UI框架，原理就是让Animator组件控制红框UI容器移动 在红框容器中再放置两个空物体作为子容器，分别是A和B，A是当前的页面，B是要打开的窗口，而B子容器部分还可再嵌套一个容器，这样移动红框容器，就可以将B部分显示出来 这时如果B部分也是一个容器，那么再移动B部分就能将C显示出来，以此类推 功能实现首先要实现的就是创建控制父容器的两个动画，移动和恢复，向左移动以显示出B子容器，向右恢复来显示A子容器，使用Ctrl+6 打开动画设置面板，选中红框容器，为其创建一个动画，创建动画的过程在这里就不赘述了，只是简单的移动Anchored Position位置，然后在Animator中为其添加展开和关闭动画，并设置is_Open bool用于值切换动画，一切准备好后，就可以为红框父容器添加一个脚本:Container 代码如下 12345678910111213141516171819202122232425262728293031323334/// &lt;summary&gt;/// 红框容器脚本/// &lt;/summary&gt;public class Container : MonoBehaviour&#123; Animator at; public Container before; //上一个容器 public Button btn_back; //返回上一个容器按钮（关闭当前窗口） public Transform A; //子容器A public Transform B; //子容器B private void Awake() &#123; at = GetComponent&lt;Animator&gt;(); // 获取动画组件 A = transform.Find("A"); //获取子容器 B = transform.Find("B"); if(btn_back!=null) btn_back.onClick.AddListener(Back);//按钮绑定事件 &#125; //设置当前是否播放动画，参数为true时，切换到B，false时切换回A public void SwitchWindow(bool b) &#123; at.SetBool("isOpen", b); &#125; //按下返回按钮 public void Back() &#123; before.SwitchWindow(false); //关闭当前窗口时，让父容器切换回A页面 //返回到上一个窗口时，将自身从父容器的B子容器中分离，因为父窗口不一定只会打开这个窗口，可能会有多个分支 transform.parent= null; gameObject.SetActive(false); //隐藏当前窗口 &#125;&#125; 这样，只需要调用SwitchWindow(bool b)方法，就能实现切换窗口，接下来要创建打开一个新窗口的脚本 123456789101112131415161718public class OpenWindow : MonoBehaviour&#123; Container Con; //当前容器 public Transform win; //下一个窗口 public Button btn; //打开按钮 private void Awake() &#123; Con = GetComponent&lt;Container&gt;(); //获取当前容器组件 btn.onClick.AddListener(() =&gt; &#123; win.parent = Con.B; //要显示的窗口设置为容器的B (win as RectTransform).anchoredPosition = Vector3.zero;//恢复0位置，相当于B容器 win.gameObject.SetActive(true); //激活显示要切换的窗口 win.GetComponent&lt;Container&gt;().before = Con; // 将当前容器传递给下一个容器 Con.SwitchWindow(true); //切换到B &#125;); &#125;&#125; 将这个脚本赋予给红框容器，然后添加打开下一个页面的按钮和下一个窗口的Transform，默认情况下要打开窗口的GameObject是禁用隐藏的，然后先将它放入当前容器的B子容器中（预备打开），将其位置归零，然后激活这个GameObj，把当前窗口的Container组件传递给新窗口（用于在新窗口关闭时调用），一切都准备就绪后，使用SwitchWindow(true)让当前红框容器动画切换到B子容器，这时控制权为B容器中的内容，是调用Back()方法返回上一个页面，还是再进入新的页面都可以。 结构图 最后Ctrl+D复制几个容器，主容器上添加OpenWindow脚本，把复制出来的容器拖入即可 总结实现这个技术主要用到了嵌套的模式结合动画来实现这个效果，有点类似于数据结构中的链栈结构，可以不断的打开新的窗口，但回退时必须要原路返回]]></content>
      <categories>
        <category>Tech</category>
        <category>Unity3D</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>UGUI</tag>
        <tag>Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity查找对象的几种方法]]></title>
    <url>%2F2018%2F11%2F08%2FUnity%E6%9F%A5%E6%89%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言在Unity开发中经常需要获取游戏对象，获取的方法有很多种本文就列举几种常用的方法 首先要了解两个类 GameObject TransformGameObject表示的是游戏对象，Transform也可以表示游戏对象，它们之间可以互相转化 12Transform t = gameobject.transform;GameObject go = t.gameobject; 而它们的区别在于：GameObject更倾向于游戏体本身的属性，如物体激活状态，物体的名称，物体的标签，物体的渲染层等设置，而Transform更多是表述模型的层级关系也就是父子关系，和本身的位置旋转缩放等信息，所以当需要查找嵌套的物体时，优先使用Transform来查找模型，GameObject更适合在不关心物体层级关系的情况下查找,且通常是使用GameObject的静态方法查找，Transform则更多调用实例方法。 通过GameObject获取 已经知道物体的名称，并且它是唯一的GameObject.Find(&quot;对象名&quot;) 已经知道物体的标签，并且是唯一的GameObject.FindWithTag(&quot;标签名&quot;) 已经知道物体的标签，且有多个，返回一个GameObject数组GameObject.FindGameObjectsWithTag(&quot;标签名&quot;) 以上方法只能查找激活状态的物体 通过Transform获取 需要获取当前物体下的某个子物体（脚本挂载当前物体上）transform.Find(&quot;直接子物体的名称 or 子物体路径&quot;)如果需要查找的物体就在当前物体下，可以直接使用物体名称，如果需要查找物体在更深的位置（当前是a物体，其下有b物体，b下有c物体），需要通过路径：”b\c”来找到c物体。 查找所有包含组件Button的物体Transform.FindObjectsOfType&lt;Button&gt;() Transform查找物体的好处是，它能找到被禁用（未激活）的物体]]></content>
      <categories>
        <category>Tech</category>
        <category>Unity3D</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown教程]]></title>
    <url>%2F2018%2F01%2F01%2FMarkDown%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一级标题二级标题一级标题二级标题三级标题四级标题五级标题六级标题斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本 分割线 RUNOOB.COMGOOGLE.COMBAIDU.COM 下划线 使劲按^sj 无序列表 无序列表 无序列表 list list list list list list 有序列表 有序列表 有序列表 嵌套列表 嵌套列表 嵌套列表 引用内容一级 引用内容二级 引用内容三级 引用嵌套列表 引用嵌套列表 有序列表 列表嵌套引用 有序列表 正文内容 print(float f)函数 黑色背景块 黑色背景块 黑色背景块 黑色背景块1234代码片段$(document).ready(function () &#123; alert('RUNOOB');&#125;); 1Console.Readkey("JJ"); link1: aalink2: 1 表格| A | B | C ||——-|——-|——|| 第一列 | 第二列 | 第三列 |]]></content>
      <categories>
        <category>Tech</category>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
